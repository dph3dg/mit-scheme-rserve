(load-option 'synchronous-subprocess)
(declare (usual-integrations))
(define *R* 0)
(define DT_STRING #x04)
(define CMD_eval #x003)
(define *header* (make-string 16 #\0))
(define *body* (make-string 16 #\0))
(define (rob-tst pro)
    (let ((x (start-pipe-subprocess (os/shell-file-name)
                                    (vector (os/shell-file-name) "-c" pro) '#())))
          (do ((i 0 (+ 1 i)))
                  ((eq? 'exited (subprocess-status x)))
;                        (display ".")
;			(newline)
;			(display (subprocess-status x))
                        (sleep-current-thread 300))
          ;    (sleep-current-thread 10000)
              (apply string (readxy (subprocess-output-port x)))
	  ;    (set! *R-process* x)
              ;    (pp (subprocess-status x))
              ))

(define (RSERVE?)
  (= 0 (run-shell-command "ps -ef | grep -v grep | grep RSERVE"
			  'output #f)))
;(not (= 0 (string-length (rob-tst "ps -ef | grep -v grep | grep RSERVE"))))



(define (start-R)
  (if (RSERVE?)
      (display "Already Running\n")
      (let ((p (start-batch-subprocess "/bin/bash" 
				       #("bash" "-c" "/usr/bin/R CMD RSERVE --no-save")
				       #f)))
    (let loop ()
      (if (eq? 'exited (subprocess-status p))
	  (display "Done\n")
	  (begin
	    (display "Waiting...\n")
	    (sleep-current-thread 300)
	    (loop)))))))

(define (stop-R)
  (run-shell-command "kill $(ps aux | grep -v grep | grep RSERVE| awk '{print $2}')" 'output #f))

(define (rserve-version)
  (display (read *R*))
  (display (read *R*))
  (display (read-char *R*))
  (display (read-char *R*))
  )
(define (connect)
  (start-R)
  (set! *R* (open-tcp-stream-socket "localhost" 6311))
;  (port/set-coding *R* 'BINARY)
  (port/set-line-ending *R* 'newline)
;  (port/set-line-ending *R* 'BINARY)
  (rserve-version))
(define (close)
  (close-port *R*)
  (stop-R))
(define (r-error?)
(= 2 (char->integer (first (string->list (substring *header* 0 1))))))

(define (eval-no-return s)
  (let* ((command CMD_eval)
         (zero-terminated (string-append s (string (integer->char 0))))
         (r-string-length (* 4 (integer-ceiling
                                (string-length zero-terminated) 4)))
         (packing (- r-string-length (string-length zero-terminated)))
         (command-length (+ 4 r-string-length))
         (pack-char (integer->char 0)))
    (display "command-length: ")
    (display command-length)
    (write-string (string-append
           (reverse-endian->string (byte-string-n command 4))
           (reverse-endian->string (byte-string-n command-length 4))
           (make-string 4 (integer->char 0))
           (make-string 4 (integer->char 0))) *R*)
    (flush-output *R*)
    (write-string (string-append (string (integer->char DT_STRING))
                (reverse-endian->string (byte-string-n r-string-length 3))
                zero-terminated (make-string packing pack-char)) *R*)
    (flush-output *R*)
;    (set! *header* (read-n-chars 16))
    (read-string! *header* *R*)
    (display (map char->integer (string->list *header*)))
    (display "numberof bytes of data: ")
    (display (parse-header->bytes-of-data))
    (set! *body* (read-n-chars (parse-header->bytes-of-data)))
    (if (r-error?)
	(display "Error!\n")
	#t)))
;    (display (length *body*))))
    
(define (eval s)
  (eval-no-return s)
    (if (not (r-error?))
	(parse-body *body*)))

(define (pad-string s)
(string-pad-left s  (* 2 (integer-ceiling (string-length s) 2)) #\0))

(define (pad-string-n s n)
(string-pad-left s  (* n (integer-ceiling (string-length s) n)) #\0))
  

(define (string-split-2 s)
  (if (= 0 (string-length s))
      '()
      (cons (substring s 0 2) (string-split-2 (string-tail s 2)))))

(define (reverse-endian->string s)
  (let* ((reversed-list-of-strings (reverse (string-split-2 s)))
        (list-of-ints (map (lambda (x) (string->number x 16))
                           reversed-list-of-strings))
        (list-of-chars (map integer->char list-of-ints)))
    (apply string list-of-chars)))
        
(define (byte-string-n m n)
  (pad-string-n (number->string m 16) (* 2 n)))
(define (n->s-hex n)
  (pad-string (number->string n 16)))
(define (parse-header->bytes-of-data)
  (string->number (apply string (map n->s-hex (reverse (map char->integer (string->list (substring *header* 4 8)))))) 16))

(define (read-n-chars n)
  (define (read-n-chars-iter n c)
    (if (= n 0)
	c
	(read-n-chars-iter (- n 1) (cons (read-char *R*) c ))))
  (read-n-chars-iter n '()))

;(define (read-n-chars n)
;  (if (= n 0)
;      '()
;      (cons (read-char *R*) (read-n-chars (- n 1)))))
(define (parse-body l)
   (let* ((r (reverse l))
	  (t1 (string-pad-left (number->string (char->integer (first r)) 16) 2 #\0))
	  (ldata (string->number (apply string (map n->s-hex (map char->integer (reverse (list (second r) (third r) (fourth r)))))) 16))
	  (t2 (string-pad-left (number->string (fix:and #x3f (char->integer (fifth r))) 16) 2 #\0))
	  (ldata2 (string->number (apply string (map n->s-hex (map
							       char->integer
							       (reverse
								(list
								 (sixth
								  r)
								 (seventh
								  r)
								 (eighth
								  r))))))
				  16))
	  (rdata (drop r 8)))
     (display "type is:")
     (display t1)
     (newline)
     (display "length of data is:")
     (display ldata)
     (newline)
     (display "SEXP header type is:")
     (display t2)
     (newline)
     (display "length of data SEXP is:")
     (display ldata2)
     (newline)
(if (string=? t2 "21")
    (reverse (walk-xl-double-array (reverse rdata)))
    (display "Only parsing float array at the moment\n"))))

(define (walk-sexp l)
  (cond ((eq? l '())
	   '())
	 (else
	    (display (get-type l))
	    (newline)
	    (display (get-length l))
	    (walk-sexp (drop l (+ 4 (get-length l)))))))
(define (get-type l)
  (string-pad-left (number->string (char->integer (first l)) 16) 2 #\0))
(define (get-length l)
  (string->number (apply string (map n->s-hex (map char->integer (reverse (list (second l) (third l) (fourth l)))))) 16))

;     (display (map char->integer r))
 ;    (reverse (walk-xl-double-array (reverse (drop r 8))))))
(define (todouble l)
;(display l)
(let* ((64bits (apply string (map 
		 (lambda (x) (string-pad-left
			      (number->string x 2) 8 #\0)) l)))
       (sign (if (equal? "1" (substring 64bits 0 1)) -1 1))
       (exponent (expt 2 (- (string->number (substring 64bits (+ 0 1)
						       (+ 11 1)) 2) 1023)))
       (mantissa (denormalise (map char->digit (string->list
						(substring 64bits (+ 0
								     1
								     11)
							   (+ 52 11
							      1))))
			      exponent)))
;(newline)  
;(display 64bits)
;(newline)
;(display sign)
;(newline)
;(display mantissa)
;(newline)
;(display exponent)
  (* sign mantissa 1.0)))
  

(define (walk-xl-double-array d)
  (if (eq? '() d)
      '()
      (cons (todouble (map char->integer (take d 8))) (walk-xl-double-array (drop d 8)))))

 
(define (denormalise l e)
  (let ((m (map (lambda (x) (/ 1 (expt 2 (+ x 1)))) (iota (length l)))))
    (* e (+ 1 (apply + (map * l m))))))
;(denormalise (map char->digit (string->list "00100000000000000000000")) 8.0)
(define (nthbit? n b)
  (if (< 0 (fix:and n (fix:lsh 1 b)))
      #t
      #f))
(define (large? n)
  (nthbit? n 6))
(define (has-attr? n)
  (nthbit? n 7))
(define (get-pure-typecode n)
  (fix:and n #x3f))

(define (list->R-string l)
  (let ((ts (apply string-append (map (lambda (x) (string-append (fluid-let ((flonum-unparser-cutoff '(normal 5 engineering)))
  (number->string (exact->inexact x))) ",")) l))))
    (string-append "c(" (string-head ts (- (string-length ts) 1)) ")")))

